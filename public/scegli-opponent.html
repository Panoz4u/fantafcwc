<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Sfida Amico - Fanteex</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,800;1,800&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/mobile.css">
  <link rel="stylesheet" href="css/mobile2.css">
</head>
<body>
  <!-- Header con freccia indietro, titolo e teex balance -->
  
  <header class="header">
    <div class="user-profile">
      <img src="icons/freccia.png" alt="Back" id="backArrow" style="width: 30px; height: 30px; cursor: pointer; margin-right: 12px;">
      <div class="user-info">
        <h1 class="user-name">SFIDA AMICO</h1>
      </div>
    </div>
    <div class="teex-balance">
         <img src="icons/ppc.png" alt="Teex" class="teex-icon">
      <span id="teexBalance" class="teex_balance">0.0</span>
    </div>


  </header>


  
  

  <!-- Search box -->
  <div class="search-container sc-select-fr">
    <span class="search-icon">üîç</span>
    <input type="text" id="searchInput" class="search-box" placeholder="Search by name">
  </div>
  
  <!-- Lista degli utenti -->
  <div class="opponent-list" id="opponentList">
    <!-- Gli utenti verranno inseriti qui dinamicamente -->
  </div>

  <script>
    // Ottieni l'ID utente dal localStorage invece che dall'URL
    const currentUser = localStorage.getItem('userId');
    // L'owner √® lo stesso utente corrente
    const ownerId = currentUser;
    // Ottieni event_unit_id dall'URL o usa un valore predefinito
    const eventUnitId = new URLSearchParams(window.location.search).get("event_unit_id") || "1";
    
    // Funzione per gestire correttamente gli avatar
    function getAvatarUrl(avatarPath) {
      if (!avatarPath) {
        return "avatars/avatar.jpg"; // Avatar di default
      }
      
      // Controlla se √® gi√† un URL completo (inizia con http o https)
      if (avatarPath.startsWith('http://') || avatarPath.startsWith('https://')) {
        return avatarPath;
      }
      
      // Altrimenti √® un nome file, aggiungi il percorso avatars/
      return `avatars/${avatarPath}`;
    }
    
    window.addEventListener("DOMContentLoaded", async () => {
      if (!currentUser) {
        alert("Utente non autenticato!");
        window.location.href = "/index.html";
        return;
      }
      
      // Add back button functionality
      document.getElementById("backArrow").addEventListener("click", () => {
        window.history.back();
      });
      
      // Carica il saldo Teex dell'utente usando il token di autenticazione
      try {
        const authToken = localStorage.getItem('authToken');
        const userResp = await fetch(`/user-landing-info`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!userResp.ok) {
          throw new Error(`Errore ${userResp.status}: ${await userResp.text()}`);
        }
        
        const userData = await userResp.json();
        document.getElementById("teexBalance").textContent = userData.user.teex_balance.toLocaleString();
      } catch(e) {
        console.error("Errore nel recupero dei dati utente", e);
      }
      
      // Carica tutti gli utenti
      try {
        const resp = await fetch("/users");
        const allUsers = await resp.json();
        const opponents = allUsers.filter(u => u.user_id != ownerId);
        
        // Ordina gli utenti per username
        opponents.sort((a, b) => a.username.localeCompare(b.username));
        
        renderOpponentList(opponents);
        
        // Aggiungi funzionalit√† di ricerca - versione alternativa
        document.getElementById("searchInput").addEventListener("input", function() {
          const searchTerm = this.value.toLowerCase().trim();
          
          // Se il campo di ricerca √® vuoto, mostra tutti gli utenti
          if (searchTerm === "") {
            renderOpponentList(opponents);
            return;
          }
          
          // Filtra gli utenti il cui nome contiene il termine di ricerca
          const filteredOpponents = [];
          for (const user of opponents) {
            if (user.username.toLowerCase().indexOf(searchTerm) !== -1 || 
                (user.email && user.email.toLowerCase().indexOf(searchTerm) !== -1)) {
              filteredOpponents.push(user);
            }
          }
          
          renderOpponentList(filteredOpponents);
        });
      } catch(e) {
        console.error("Errore fetch /users", e);
      }
    });
    
    function renderOpponentList(opponents) {
      const opponentList = document.getElementById("opponentList");
      opponentList.innerHTML = "";
      
      if (opponents.length === 0) {
        opponentList.innerHTML = "<p style='text-align: center; color: #ccc; margin-top: 20px;'>Nessun utente trovato</p>";
        return;
      }
      
      opponents.forEach(user => {
        const opponentItem = document.createElement("div");
        opponentItem.className = "opponent-item";
        opponentItem.style.cursor = "pointer"; // Aggiungi cursore pointer per indicare che √® cliccabile
        
        // Usa la funzione getAvatarUrl per gestire correttamente gli avatar
        const avatarSrc = getAvatarUrl(user.avatar);
        
        opponentItem.innerHTML = `
          <div class="opponent-info">
            <img src="${avatarSrc}" alt="${user.username}" class="opponent-avatar">
            <div>
              <h3 class="opponent-name">${user.username}</h3>

            </div>
          </div>
          <button class="play-contest-button" data-id="${user.user_id}">PLAY</button>
        `;
        
        // Aggiungi l'attributo data-id anche all'elemento opponentItem
        opponentItem.setAttribute("data-id", user.user_id);
        
        opponentList.appendChild(opponentItem);
      });
      
      // Funzione per gestire la creazione del contest
      async function createContest(oppId) {
        try {
          const resp = await fetch("/contests", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              owner: ownerId,
              opponent: oppId,
              event_unit_id: eventUnitId,
              multiply: 1  // Aggiungo il valore predefinito per multiply
            })
          });
          if (!resp.ok) {
            const err = await resp.json();
            alert("Errore creazione contest: " + err.error);
            return;
          }
          const data = await resp.json(); // contestId
          
          // Salva i dati nel localStorage invece di passarli nell'URL
          localStorage.setItem('contestData', JSON.stringify({
            contestId: data.contestId,
            event_unit_id: eventUnitId,
            eventUnitId: eventUnitId, // Aggiungi anche questo campo per compatibilit√†
            opponentId: oppId,
            ownerId: ownerId,
            userId: currentUser,
            timestamp: new Date().getTime()
          }));
          
          // Reindirizza alla pagina riassunto
          window.location.href = `/riassunto.html`;
        } catch (e) {
          console.error("Errore POST /contests", e);
          alert("Impossibile creare contest");
        }
      }
      
      // Aggiungi event listener ai pulsanti PLAY
      document.querySelectorAll(".play-contest-button").forEach(button => {
        button.addEventListener("click", (event) => {
          event.stopPropagation(); // Impedisci che l'evento si propaghi all'elemento genitore
          const oppId = button.getAttribute("data-id");
          createContest(oppId);
        });
      });
      
      // Aggiungi event listener alle righe degli utenti
      document.querySelectorAll(".opponent-item").forEach(item => {
        item.addEventListener("click", () => {
          const oppId = item.getAttribute("data-id");
          createContest(oppId);
        });
      });
    }
  </script>
</body>
</html>
