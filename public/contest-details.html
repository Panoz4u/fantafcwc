<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Contest Details - FANTAEUROVISION25</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,800;1,800&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/mobile.css">
  <link rel="stylesheet" href="css/mobile2.css">
  <!-- Corretto il riferimento al file delle funzioni avatar -->
  <script src="/js/avatar-functions.js"></script>
</head>
<body>
  <!-- Header principale -->
  <header class="header">
    <div class="user-profile">
      <img src="icons/freccia.png" alt="Back" id="backArrow" style="width: 30px; height: 30px; cursor: pointer; margin-right: 12px;">
      <div class="user-info">
        <h1 class="user-name">MATCH DETAILS</h1>
      </div>
    </div>
    <div class="teex-balance">
       <img src="icons/sh.png" alt="Teex" class="teex-icon">
      <span id="teexContainer" class="teex_balance">0.0</span>
    </div>


  </header>



  <!-- Messaggio di errore -->
  <div id="errorMessage" style="display: none; color: red; padding: 10px; margin: 10px; background-color: rgba(255, 0, 0, 0.1); border-radius: 5px;"></div>

  <div class="contest-container cc-header" id="contestHeaderContainer">
    <!-- Il contest verrà renderizzato qui -->
  </div>

  <!-- Blocco nomi utenti -->
  <div id="userNamesBlock" class="contest_usernames">
    <div id="leftUserName" class="full_username full_username_left"></div>
    <div id="rightUserName" class="full_username full_username_right"></div>
  </div>

  <!-- Sezione Teams: Liste dei giocatori -->
  <section class="teams-section">
    <!-- Lista Squadra Sinistra (utente corrente) -->
    <div class="team-container left-team" id="leftTeamContainer">
      <div class="team-list" id="leftTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
    <!-- Lista Squadra Destra (avversario) -->
    <div class="team-container right-team" id="rightTeamContainer">
      <div class="team-list" id="rightTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
  </section>

  <!-- Footer bar (semi-transparent, no icons) -->
  <!-- Footer bar with buttons aligned to the right
    <footer class="footer-nav" style="justify-content: flex-end; ">
      <button class="footer_button footer_button_blue">SHARE</button>
      <button class="footer_button footer_button_orange">REMATCH</button>
    </footer>
    -->
  <script>
    // Funzione per ottenere l'URL dell'avatar
    function getAvatarSrc(avatar, username, userColor) {
      if (avatar && avatar.trim() !== "") {
        if (avatar.startsWith("http")) {
          // Per gli URL di Google, assicuriamoci che non ci siano problemi di encoding
          if (avatar.includes("googleusercontent.com")) {
            // Decodifica l'URL per assicurarsi che non ci siano problemi di encoding
            return decodeURIComponent(avatar);
          }
          return avatar;
        } else {
          return "avatars/" + avatar;
        }
      } else {
        // Se non c'è avatar, generiamo un data URL con un cerchio colorato e le iniziali
        return generateColoredInitialsAvatar(username, userColor);
      }
    }

    // Funzione per generare un avatar colorato con le iniziali
    function generateColoredInitialsAvatar(username, color) {
      // Usa un colore predefinito se non è specificato
      const bgColor = color || "ff5500";
      
      // Ottieni le prime 3 lettere dello username (o meno se lo username è più corto)
      const initials = username ? username.substring(0, 3).toUpperCase() : "?";
      
      // Crea un canvas temporaneo
      const canvas = document.createElement("canvas");
      canvas.width = 200;
      canvas.height = 200;
      const ctx = canvas.getContext("2d");
      
      // Disegna il cerchio colorato
      ctx.fillStyle = "#" + bgColor;
      ctx.beginPath();
      ctx.arc(100, 100, 100, 0, Math.PI * 2);
      ctx.fill();
      
      // Imposta lo stile del testo
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 80px 'Barlow Condensed', sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // Disegna le iniziali
      ctx.fillText(initials, 100, 100);
      
      // Converti il canvas in un data URL
      return canvas.toDataURL("image/png");
    }

    // Legge i parametri dal localStorage invece che dalla query string
    const contestId = localStorage.getItem("contestId");
    const currentUserId = localStorage.getItem("userId");
    const eventUnitId = localStorage.getItem("eventUnitId");
    const authToken = localStorage.getItem("authToken");
    const ownerId = localStorage.getItem("ownerId");
    const opponentId = localStorage.getItem("opponentId");

    console.log("Parametri caricati dal localStorage:", {
      contestId,
      currentUserId,
      eventUnitId,
      authToken,
      ownerId,
      opponentId
    });

    // Carica il Teex balance
    async function loadTeexBalance() {
      try {
        const resp = await fetch("/user-landing-info", {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        if (resp.ok) {
          const data = await resp.json();
          const teexContainer = document.getElementById("teexContainer");
          if (teexContainer) {
            teexContainer.textContent = parseFloat(data.user.teex_balance).toFixed(1);
          }
        } else {
          const teexContainer = document.getElementById("teexContainer");
          if (teexContainer) {
            teexContainer.textContent = "0.0";
          }
        }
      } catch (error) {
        console.error("Error loading teex balance:", error);
        const teexContainer = document.getElementById("teexContainer");
        if (teexContainer) {
          teexContainer.textContent = "0.0";
        }
      }
    }

    // Click sulla freccia torna alla landing
    document.getElementById("backArrow").addEventListener("click", () => {
      window.location.href = "/user-landing.html";
    });

    // Carica i dettagli del contest
    async function loadContestDetails() {
      try {
        if (!contestId || !authToken) {
          console.error("Parametri mancanti: contestId o authToken");
          showError("Parametri mancanti. Torna alla pagina precedente.");
          return;
        }
        
        // Recupera ownerId e opponentId dal localStorage
        const ownerId = localStorage.getItem("ownerId");
        const opponentId = localStorage.getItem("opponentId");
        
        console.log("Owner ID:", ownerId);
        console.log("Opponent ID:", opponentId);
        
        // Assicurati che entrambi i valori siano presenti
        if (!ownerId || !opponentId) {
          console.error("Parametri mancanti: ownerId o opponentId");
          showError("Informazioni utente mancanti. Torna alla pagina precedente.");
          return;
        }
        
        // Prepara i dati da inviare
        const requestData = {
          contest_id: parseInt(contestId),
          owner_id: parseInt(ownerId),
          opponent_id: parseInt(opponentId)
        };
        
        console.log("Dati inviati al server:", JSON.stringify(requestData));
        
        // Effettua la richiesta al server
        const resp = await fetch("/contests/contest-details", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${authToken}`
          },
          body: JSON.stringify(requestData)
        });
        
        console.log("Risposta del server:", resp.status, resp.statusText);
        
        if (!resp.ok) {
          const errorText = await resp.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
            console.log("Errore JSON completo:", errorData);
          } catch (e) {
            errorData = { error: errorText };
            console.log("Errore testo completo:", errorText);
          }
          
          console.error("Errore caricamento dettagli:", resp.status, errorData);
          
          // Crea l'elemento errorMessage se non esiste
          let errorMessage = document.getElementById("errorMessage");
          if (!errorMessage) {
            errorMessage = document.createElement("div");
            errorMessage.id = "errorMessage";
            errorMessage.style.color = "red";
            errorMessage.style.padding = "10px";
            errorMessage.style.margin = "10px";
            errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
            errorMessage.style.borderRadius = "5px";
            document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
          }
          
          errorMessage.textContent = `Errore: ${errorData.error || "Impossibile caricare i dettagli"}`;
          errorMessage.style.display = "block";
          return;
        }
        
        // Corretto: usa resp invece di response
        const data = await resp.json();
        console.log("Contest data:", data);
        
        // Verifica che i dati necessari esistano
        if (!data.contest) {
          console.error("Dati del contest mancanti nella risposta");
          let errorMessage = document.getElementById("errorMessage");
          if (!errorMessage) {
            errorMessage = document.createElement("div");
            errorMessage.id = "errorMessage";
            errorMessage.style.color = "red";
            errorMessage.style.padding = "10px";
            errorMessage.style.margin = "10px";
            errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
            errorMessage.style.borderRadius = "5px";
            document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
          }
          errorMessage.textContent = "Dati del contest mancanti nella risposta";
          errorMessage.style.display = "block";
          return;
        }
        
        console.log("Contest status:", data.contest.status);
        if (data.contest.fantasy_teams) {
          console.log("Fantasy teams:", data.contest.fantasy_teams);
        }
        
        // Popola i nomi nel blocco sotto il contest header
        const iAmOwner = (parseInt(currentUserId) === parseInt(data.contest.owner_id));
        
        const leftUserName = document.getElementById("leftUserName");
        const rightUserName = document.getElementById("rightUserName");
        
        if (leftUserName && rightUserName) {
          if (iAmOwner) {
            leftUserName.textContent = data.contest.owner_name;
            rightUserName.textContent = data.contest.opponent_name;
          } else {
            leftUserName.textContent = data.contest.opponent_name;
            rightUserName.textContent = data.contest.owner_name;
          }
        }
        
        // Renderizza l'header del contest usando lo stesso layout di user-landing.html
        renderContestHeader(data.contest);
        
        // Renderizza le liste dei giocatori
        if (typeof renderTeamLists === 'function') {
          renderTeamLists(data.ownerTeam, data.opponentTeam, data.contest);
        } else {
          console.warn("La funzione renderTeamLists non è definita");
        }
      } catch (error) {
        console.error("Error loading contest details", error);
        
        // Crea l'elemento errorMessage se non esiste
        let errorMessage = document.getElementById("errorMessage");
        if (!errorMessage) {
          errorMessage = document.createElement("div");
          errorMessage.id = "errorMessage";
          errorMessage.style.color = "red";
          errorMessage.style.padding = "10px";
          errorMessage.style.margin = "10px";
          errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
          errorMessage.style.borderRadius = "5px";
          document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
        }
        
        errorMessage.textContent = "Si è verificato un errore durante il caricamento dei dettagli.";
        errorMessage.style.display = "block";
      }
    }

    // Renderizza l'header del contest usando lo stesso layout di user-landing.html
    function renderContestHeader(contestData) {
      const container = document.getElementById("contestHeaderContainer");
      container.innerHTML = "";
      
      // Determina se il current user è owner
      const iAmOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));
      
      let myName, myAvatar, myCost, oppName, oppAvatar, oppCost, myColor, oppColor;
      if (iAmOwner) {
        myName = contestData.owner_name;
        myAvatar = contestData.owner_avatar;
        myColor = contestData.owner_color || "ff5500"; // Valore predefinito se non esiste
        myCost = contestData.owner_cost || "-";
        oppName = contestData.opponent_name;
        oppAvatar = contestData.opponent_avatar;
        oppColor = contestData.opponent_color || "ff5500"; // Valore predefinito se non esiste
        oppCost = contestData.opponent_cost || "-";
      } else {
        myName = contestData.opponent_name;
        myAvatar = contestData.opponent_avatar;
        myColor = contestData.opponent_color || "ff5500"; // Valore predefinito se non esiste
        myCost = contestData.opponent_cost || "-";
        oppName = contestData.owner_name;
        oppAvatar = contestData.owner_avatar;
        oppColor = contestData.owner_color || "ff5500"; // Valore predefinito se non esiste
        oppCost = contestData.owner_cost || "-";
      }
      
      // Crea la card del contest
      const contestCard = document.createElement("div");
      contestCard.classList.add("contest-cell");
      
      // Determina il layout in base allo stato del contest
      if (contestData.status == 1 && iAmOwner) {
        // Layout per contest in stato "pending" dove sono il proprietario
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">-</div>
            </div>
            <div class="status-badge-base status-badge">PENDING</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 1 && !iAmOwner) {
        // Layout per contest in stato "invited" dove sono l'invitato
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">-</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-invited">INVITED</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 2) {
        // Layout per contest in stato "ready"
        
        // Ottieni i punteggi dai total_points dei fantasy_teams (anche se potrebbero essere 0)
        let leftScore = 0;
        let rightScore = 0;
        
        // Utilizziamo il nuovo endpoint per ottenere i punteggi aggiornati
        fetch(`/fantasy/contest-points?contest_id=${contestData.contest_id}`)
          .then(response => response.json())
          .then(data => {
            console.log("Dati dei punteggi ricevuti:", data);
            console.log(`Risultati calculateContestPoints per contest ${contestData.contest_id}:`, data);
            
            // Assegna i punteggi in base a se l'utente è owner o opponent
            if (iAmOwner) {
              leftScore = parseFloat(data.owner_points || 0);
              rightScore = parseFloat(data.opponent_points || 0);
            } else {
              leftScore = parseFloat(data.opponent_points || 0);
              rightScore = parseFloat(data.owner_points || 0);
            }
            
            const leftScoreStr = leftScore.toFixed(1);
            const rightScoreStr = rightScore.toFixed(1);
            
            const [leftScoreInt, leftScoreDec = "0"] = leftScoreStr.split('.');
            const [rightScoreInt, rightScoreDec = "0"] = rightScoreStr.split('.');
            
            // Aggiorna il contenuto HTML con i punteggi calcolati
            const scoreContainer = contestCard.querySelector('.contest-bar div[style*="display: flex"]');
            if (scoreContainer) {
              scoreContainer.innerHTML = `
                <div class="result_bold_2">VS</div>`;
            }
          })
          .catch(error => {
            console.error(`Errore nel recupero dei punti per il contest ${contestData.contest_id}:`, error);
          });
        
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar, myName, myColor)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;">
                <span class="result_bold" style="position: static; transform: none; color: #fff">0</span>
                <span class="win_index_perc" style="color: #fff">.0</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff">0</span>
                <span class="win_index_perc" style="color: #fff">.0</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar, oppName, oppColor)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-ready">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 4) {
        // Layout per contest in stato "in progress"
        let leftScore = 0;
        let rightScore = 0;
        
        // Prima creiamo l'HTML con valori predefiniti
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar, myName, myColor)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;" id="scoreDisplay">
                <span class="result_bold" style="position: static; transform: none; color: #fff" id="leftScoreInt">0</span>
                <span class="win_index_perc" style="color: #fff" id="leftScoreDec">.0</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff" id="rightScoreInt">0</span>
                <span class="win_index_perc" style="color: #fff" id="rightScoreDec">.0</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar, oppName, oppColor)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-live">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
        
        // Poi aggiorniamo i valori con i dati dell'API
        fetch(`/fantasy/contest-points?contest_id=${contestData.contest_id}`)
          .then(response => response.json())
          .then(data => {
            console.log("Dati dei punteggi ricevuti:", data);
            
            // Assegna i punteggi in base a se l'utente è owner o opponent
            if (iAmOwner) {
              leftScore = parseFloat(data.owner_points || 0);
              rightScore = parseFloat(data.opponent_points || 0);
            } else {
              leftScore = parseFloat(data.opponent_points || 0);
              rightScore = parseFloat(data.owner_points || 0);
            }
            
            console.log("Punteggi calcolati:", {leftScore, rightScore, iAmOwner});
            
            const leftScoreStr = leftScore.toFixed(1);
            const rightScoreStr = rightScore.toFixed(1);
            
            const [leftScoreInt, leftScoreDec = "0"] = leftScoreStr.split('.');
            const [rightScoreInt, rightScoreDec = "0"] = rightScoreStr.split('.');
            
            // Aggiorna gli elementi con ID specifici
            document.getElementById("leftScoreInt").textContent = leftScoreInt;
            document.getElementById("leftScoreDec").textContent = `.${leftScoreDec}`;
            document.getElementById("rightScoreInt").textContent = rightScoreInt;
            document.getElementById("rightScoreDec").textContent = `.${rightScoreDec}`;
          })
          .catch(error => {
            console.error(`Errore nel recupero dei punti per il contest ${contestData.contest_id}:`, error);
          });
      } else if (contestData.status == 5) {
        // Layout per contest in stato "completed"
        let leftScore = 0;
        let rightScore = 0;
        let myResult = 0;
        let myTeexWon = 0;
        let teexWonDisplay = 0;
        
        // Determina il risultato
        if (contestData.result) {
          const parts = contestData.result.split('-');
          if (parts.length === 2) {
            if (iAmOwner) {
              leftScore = parseFloat(parts[0]) || 0;
              rightScore = parseFloat(parts[1]) || 0;
            } else {
              leftScore = parseFloat(parts[1]) || 0;
              rightScore = parseFloat(parts[0]) || 0;
            }
            
            // Determina il risultato (1 = vittoria, 0 = pareggio, -1 = sconfitta)
            if (leftScore > rightScore) {
              myResult = 1;
            } else if (leftScore < rightScore) {
              myResult = -1;
            } else {
              myResult = 0; // Pareggio
            }
          }
        }
        
        // Ottieni i dati dai fantasy_teams
        if (contestData.fantasy_teams && contestData.fantasy_teams.length > 0) {
          contestData.fantasy_teams.forEach(team => {
            if ((iAmOwner && team.user_id == contestData.owner_id) || 
                (!iAmOwner && team.user_id == contestData.opponent_id)) {
              // Prendi il valore ft_teex_won dal team dell'utente corrente
              myTeexWon = parseFloat(team.ft_teex_won || 0);
              leftScore = parseFloat(team.total_points || 0);
            } else {
              rightScore = parseFloat(team.total_points || 0);
            }
          });
        }
        
        // Calcola il valore da visualizzare
        const myCost = parseFloat(iAmOwner ? contestData.owner_cost : contestData.opponent_cost || 0);
        const multiply = parseFloat(contestData.multiply || 1);
        
        // Applica la formula richiesta: ft_teex_won - ((user_cost) * multiply))
        teexWonDisplay = myTeexWon - (myCost * multiply);
        
        // Aggiungi i log per il debug
        console.log("Debug valori:");
        console.log("leftScore:", leftScore);
        console.log("rightScore:", rightScore);
        console.log("myResult:", myResult);
        console.log("myTeexWon:", myTeexWon);
        console.log("teexWonDisplay:", teexWonDisplay);
        console.log("myCost:", myCost);
        console.log("multiply:", multiply);
        
        // Determina lo stile del badge in base al valore di teexWonDisplay
        let badgeClass = "status-badge-draw";
        if (teexWonDisplay > 0) {
          badgeClass = "status-badge-win";
        } else if (teexWonDisplay < 0) {
          badgeClass = "status-badge-loss";
        }
        
        // Formatta i punteggi per la visualizzazione
        const leftScoreStr = leftScore.toFixed(1);
        const rightScoreStr = rightScore.toFixed(1);
        
        const [leftScoreInt, leftScoreDec = "0"] = leftScoreStr.split('.');
        const [rightScoreInt, rightScoreDec = "0"] = rightScoreStr.split('.');
        
        // Formatta i teex vinti per la visualizzazione
        const teexWonDisplayStr = Math.abs(teexWonDisplay).toFixed(1);

        // Determina il segno da visualizzare
        const teexWonSign = teexWonDisplay < 0 ? '-' : '+';

        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;">
                <span class="result_bold" style="position: static; transform: none; color: #fff">${leftScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${leftScoreDec}</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff">${rightScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${rightScoreDec}</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base ${badgeClass}">${teexWonSign}${teexWonDisplayStr}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } 

      // Aggiungi la card al container
      container.appendChild(contestCard);
    }/* helper per aggiornare i punti */
function updatePointsDisplay(points, isEnded, container) {
  container.innerHTML = "";
  const ptsStr = points.toFixed(1);
  const [ptsInt, ptsDec] = ptsStr.split('.');

  const intSpan = document.createElement("span");
  intSpan.classList.add("athlete_points_integer", isEnded ? "is_ended" : "not_ended");
  intSpan.textContent = ptsInt;

  const decSpan = document.createElement("span");
  decSpan.classList.add("athlete_points_decimal", isEnded ? "is_ended" : "not_ended");
  decSpan.textContent = `.${ptsDec}`;

  container.appendChild(intSpan);
  container.appendChild(decSpan);
}

function renderTeamLists(ownerTeam, opponentTeam, contestData) {
  const leftTeamList = document.getElementById("leftTeamList");
  const rightTeamList = document.getElementById("rightTeamList");
  leftTeamList.innerHTML = "";
  rightTeamList.innerHTML = "";

  const isCurrentUserOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));

  if (isCurrentUserOwner) {
    ownerTeam.forEach(player => {
      leftTeamList.appendChild(createPlayerRow(player, "left"));
    });
    opponentTeam.forEach(player => {
      rightTeamList.appendChild(createPlayerRow(player, "right"));
    });
  } else {
    opponentTeam.forEach(player => {
      leftTeamList.appendChild(createPlayerRow(player, "left"));
    });
    ownerTeam.forEach(player => {
      rightTeamList.appendChild(createPlayerRow(player, "right"));
    });
  }
}

function createPlayerRow(player, side) {
  const wrapper = document.createElement("div");
  const row = document.createElement("div");
  row.classList.add("player-row");

  // Avatar block
  const avatarBlock = document.createElement("div");
  avatarBlock.classList.add("avatar-block");
  avatarBlock.style.position = "relative";

  const avatarContainer = document.createElement("div");
  avatarContainer.classList.add("atheleteAvatar");
  const iconImg = document.createElement("img");
  iconImg.src = player.picture ? `pictures/${player.picture}` : `pictures/player_placeholder.png`;
  iconImg.onerror = function() { this.src = 'pictures/player_placeholder.png'; };
  avatarContainer.appendChild(iconImg);

//  const posCircle = document.createElement("div");
//  posCircle.classList.add("position_circle", player.position);
//  posCircle.textContent = player.position;

  avatarBlock.appendChild(avatarContainer);
//  avatarBlock.appendChild(posCircle);

  // Info block
  const infoBlock = document.createElement("div");
  infoBlock.classList.add("player-info");

  const nameSpan = document.createElement("div");
  nameSpan.classList.add("athlete_shortname");
  nameSpan.textContent = player.athlete_shortname;

  const matchSpan = document.createElement("div");
  matchSpan.classList.add("match_3letter");
  matchSpan.innerHTML = `<span style="font-weight: 800;">${player.player_team_code || ''}</span>`;
  // Rimuoviamo il riferimento allo span dell'event ID poiché non lo utilizzeremo più
  // const eventUnitSpan = matchSpan.querySelector('span:last-child');

  infoBlock.appendChild(nameSpan);
  infoBlock.appendChild(matchSpan);

  // Punti & costo
  const pointsCostBlock = document.createElement("div");
  pointsCostBlock.classList.add("points-cost-block");
  const pointsContainer = document.createElement("div");
  pointsContainer.classList.add("points-container");



  const costSpan = document.createElement("div");
  costSpan.classList.add("athlete_cost");
  costSpan.textContent = parseFloat(player.cost || 0).toFixed(1);

  // Fetch per event_unit_id e punti
  let playerUnitPoints = 0;
  if (player.aep_id) {
    fetch(`/aep-event-unit?aep_id=${player.aep_id}`)
      .then(res => res.json())
      .then(data => {

        if (data.athlete_unit_points != null) {
          playerUnitPoints = parseFloat(data.athlete_unit_points) || 0;
          // Usa il valore is_ended che arriva dall'API invece di quello definito localmente
          console.log("❓ Dati ricevuti da /aep-event-unit:", data);
          const isEnded = data.is_ended === 1 || data.is_ended === true;
          updatePointsDisplay(playerUnitPoints, isEnded, pointsContainer);
        }
      })
      
  }

  // Mostro "0.0" di default, verrà aggiornato dal fetch
  updatePointsDisplay(0, false, pointsContainer);
  
  pointsCostBlock.appendChild(pointsContainer);
  pointsCostBlock.appendChild(costSpan);

  // Posizionamento lato
  if (side === "left") {
    row.appendChild(avatarBlock);
    row.appendChild(infoBlock);
    row.appendChild(pointsCostBlock);
  } else {
    row.appendChild(pointsCostBlock);
    row.appendChild(infoBlock);
    row.appendChild(avatarBlock);
  }

  wrapper.appendChild(row);
  const separator = document.createElement("div");
  separator.classList.add("player-separator");
  wrapper.appendChild(separator);

  return wrapper;
}

// Init al DOM ready
document.addEventListener("DOMContentLoaded", async () => {
  try {
    await loadTeexBalance();
    await loadContestDetails();
    const backArrow = document.getElementById("backArrow");
    if (backArrow) backArrow.addEventListener("click", () => {
      window.location.href = "/user-landing.html";
    });
  } catch (error) {
    console.error("Errore durante il caricamento della pagina:", error);
    // gestione errore…
  }
});

  </script>
</body>
</html>
