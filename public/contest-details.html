<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Contest Details - Fanteex</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,800;1,800&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/mobile.css">
  <link rel="stylesheet" href="css/mobile2.css">
  <!-- Aggiungi il riferimento al file avatarUtils.js -->
  <script src="js/avatarUtils.js"></script>
</head>
<body>
  <!-- Header principale -->
  <header class="header">
    <div class="user-profile">
      <img src="icons/freccia.png" alt="Back" id="backArrow" style="width: 30px; height: 30px; cursor: pointer; margin-right: 12px;">
      <div class="user-info">
        <h1 class="user-name">MATCH DETAILS</h1>
      </div>
    </div>
    <div class="teex-balance">
       <img src="icons/ppc.png" alt="Teex" class="teex-icon">
      <span id="teexContainer" class="teex_balance">0.0</span>
    </div>


  </header>



  <div class="contest-container cc-header" id="contestHeaderContainer">
    <!-- Il contest verrà renderizzato qui -->
  </div>

  <!-- Blocco nomi utenti -->
  <div id="userNamesBlock" class="contest_usernames">
    <div id="leftUserName" class="full_username full_username_left"></div>
    <div id="rightUserName" class="full_username full_username_right"></div>
  </div>

  <!-- Sezione Teams: Liste dei giocatori -->
  <section class="teams-section">
    <!-- Lista Squadra Sinistra (utente corrente) -->
    <div class="team-container left-team" id="leftTeamContainer">
      <div class="team-list" id="leftTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
    <!-- Lista Squadra Destra (avversario) -->
    <div class="team-container right-team" id="rightTeamContainer">
      <div class="team-list" id="rightTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
  </section>

  <!-- Footer bar (semi-transparent, no icons) -->
  <!-- Footer bar with buttons aligned to the right -->
    <footer class="footer-nav" style="justify-content: flex-end; ">
      <button class="footer_button footer_button_blue">SHARE</button>
      <button class="footer_button footer_button_orange">REMATCH</button>
    </footer>

  <script>
    // Legge i parametri dal localStorage invece che dalla query string
    const contestId = localStorage.getItem("contestId");
    const currentUserId = localStorage.getItem("userId");
    const eventUnitId = localStorage.getItem("eventUnitId");
    const authToken = localStorage.getItem("authToken");

    console.log("Parametri caricati dal localStorage:", {
      contestId,
      currentUserId,
      eventUnitId,
      authToken
    });

    // Carica il Teex balance
    async function loadTeexBalance() {
      try {
        const resp = await fetch("/user-landing-info", {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        if (resp.ok) {
          const data = await resp.json();
          document.getElementById("teexContainer").textContent = parseFloat(data.user.teex_balance).toFixed(1);
        } else {
          document.getElementById("teexContainer").textContent = "0.0";
        }
      } catch (error) {
        console.error("Error loading teex balance:", error);
        document.getElementById("teexContainer").textContent = "0.0";
      }
    }

    // Click sulla freccia torna alla landing
    document.getElementById("backArrow").addEventListener("click", () => {
      window.location.href = "/user-landing.html";
    });

    // Carica i dettagli del contest
    // Carica i dettagli del contest
    async function loadContestDetails() {
      if (!contestId || !currentUserId) {
        console.error("Parametri mancanti:", { contestId, currentUserId });
        document.body.innerHTML = "<h1>Parametri mancanti! Torna alla pagina precedente.</h1>";
        return;
      }
      try {
        // Modifica la chiamata API per utilizzare POST invece di GET
        const resp = await fetch(`/contest-details`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contest_id: contestId,
            user_id: currentUserId,
            event_unit_id: eventUnitId || undefined
          })
        });
        if (!resp.ok) {
          document.body.innerHTML = "<h1>Error loading contest details!</h1>";
          return;
        }
        const data = await resp.json();
        console.log("Contest data:", data);
        console.log("Contest status:", data.contest.status);
        console.log("Fantasy teams:", data.contest.fantasy_teams);
        
        // RIMUOVI QUESTO BLOCCO - Non sovrascrivere i dati dei fantasy teams
        /*
        if (data.contest.status == 5) {
          data.contest.fantasy_teams = [];
          
          // Aggiungi il team dell'owner se disponibile
          if (data.ownerTeam && data.ownerTeam.length > 0) {
            const ownerTeamData = {
              user_id: data.contest.owner_id,
              total_points: data.ownerTeamPoints || 0,
              ft_result: data.ownerTeamResult || 0,
              ft_teex_won: data.ownerTeamTeexWon || 0
            };
            data.contest.fantasy_teams.push(ownerTeamData);
          }
          
          // Aggiungi il team dell'opponent se disponibile
          if (data.opponentTeam && data.opponentTeam.length > 0) {
            const opponentTeamData = {
              user_id: data.contest.opponent_id,
              total_points: data.opponentTeamPoints || 0,
              ft_result: data.opponentTeamResult || 0,
              ft_teex_won: data.opponentTeamTeexWon || 0
            };
            data.contest.fantasy_teams.push(opponentTeamData);
          }
        }
        */
        
        // Popola i nomi nel blocco sotto il contest header
        const iAmOwner = (parseInt(currentUserId) === parseInt(data.contest.owner_id));
        if (iAmOwner) {
          document.getElementById("leftUserName").textContent = data.contest.owner_name;
          document.getElementById("rightUserName").textContent = data.contest.opponent_name;
        } else {
          document.getElementById("leftUserName").textContent = data.contest.opponent_name;
          document.getElementById("rightUserName").textContent = data.contest.owner_name;
        }
        
        // Renderizza l'header del contest usando lo stesso layout di user-landing.html
        renderContestHeader(data.contest);



        // Renderizza le liste dei giocatori
        renderTeamLists(data.ownerTeam, data.opponentTeam, data.contest);
      } catch (error) {
        console.error("Error loading contest details", error);
        document.body.innerHTML = "<h1>Error loading contest details!</h1>";
      }
    }

    // Renderizza l'header del contest usando lo stesso layout di user-landing.html
    function renderContestHeader(contestData) {
      const container = document.getElementById("contestHeaderContainer");
      container.innerHTML = "";
      
      // Determina se il current user è owner
      const iAmOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));
      
      let myName, myAvatar, myCost, oppName, oppAvatar, oppCost;
      if (iAmOwner) {
        myName = contestData.owner_name;
        myAvatar = contestData.owner_avatar;
        myCost = contestData.owner_cost || "-";
        oppName = contestData.opponent_name;
        oppAvatar = contestData.opponent_avatar;
        oppCost = contestData.opponent_cost || "-";
      } else {
        myName = contestData.opponent_name;
        myAvatar = contestData.opponent_avatar;
        myCost = contestData.opponent_cost || "-";
        oppName = contestData.owner_name;
        oppAvatar = contestData.owner_avatar;
        oppCost = contestData.owner_cost || "-";
      }
      
      // Crea la card del contest
      const contestCard = document.createElement("div");
      contestCard.classList.add("contest-cell");
      
      // Determina il layout in base allo stato del contest
      if (contestData.status == 1 && iAmOwner) {
        // Layout per contest in stato "pending" dove sono il proprietario
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">-</div>
            </div>
            <div class="status-badge-base status-badge">PENDING</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 1 && !iAmOwner) {
        // Layout per contest in stato "invited" dove sono l'invitato
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">-</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-invited">INVITED</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 2) {
        // Layout per contest in stato "ready"
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-ready">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 4) {
        // Layout per contest in stato "in progress"
        let leftScore = 0;
        let rightScore = 0;
        
        // Use the result field directly from contestData without swapping
        if (contestData.result) {
          const parts = contestData.result.split('-');
          if (parts.length === 2) {
            // Always use the result in the exact order it comes from the server
            leftScore = parseFloat(parts[0]) || 0;
            rightScore = parseFloat(parts[1]) || 0;
          }
        }
        
        const leftScoreStr = leftScore.toFixed(1);
        const rightScoreStr = rightScore.toFixed(1);
        
        const [leftScoreInt, leftScoreDec = "0"] = leftScoreStr.split('.');
        const [rightScoreInt, rightScoreDec = "0"] = rightScoreStr.split('.');
        
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;">
                <span class="result_bold" style="position: static; transform: none; color: #fff">${leftScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${leftScoreDec}</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff">${rightScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${rightScoreDec}</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-live">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 5) {
        // Layout per contest in stato "completed"
        // Ottieni i punteggi dai total_points dei fantasy_teams
        let myPoints = 0;
        let oppPoints = 0;
        let myResult = 0;
        let myTeexWon = 0;
        
        // Estrai i dati dai fantasy_teams
        if (contestData.fantasy_teams && contestData.fantasy_teams.length > 0) {
          contestData.fantasy_teams.forEach(team => {
            if ((iAmOwner && team.user_id == contestData.owner_id) || 
                (!iAmOwner && team.user_id == contestData.opponent_id)) {
              myPoints = parseFloat(team.total_points || 0);
              myResult = parseInt(team.ft_result || 0);
              myTeexWon = parseFloat(team.ft_teex_won || 0);
            } else {
              oppPoints = parseFloat(team.total_points || 0);
            }
          });
        }
        
        const myPointsStr = myPoints.toFixed(1);
        const oppPointsStr = oppPoints.toFixed(1);
        
        const [myPointsInt, myPointsDec = "0"] = myPointsStr.split('.');
        const [oppPointsInt, oppPointsDec = "0"] = oppPointsStr.split('.');
        
        // Determina lo stile del badge in base al risultato
        let badgeClass = "status-badge-live";
        let badgeText = "";
        
        if (myResult === 1) {
          // Vittoria
          badgeClass = "status-badge-base status-badge-win"; // Sfondo verde
          badgeText = `+${myTeexWon.toFixed(1)}`;
        } else if (myResult === -1) {
          // Sconfitta
          badgeClass = "status-badge-base status-badge-loss"; // Sfondo fucsia
          badgeText = `${myTeexWon.toFixed(1)}`; // Il valore è già negativo
        } else {
          // Pareggio
          badgeClass = "status-badge-base status-badge-draw"; // Sfondo arancione
          badgeText = myTeexWon >= 0 ? `+${myTeexWon.toFixed(1)}` : `${myTeexWon.toFixed(1)}`;
        }
        
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;">
                <span class="result_bold" style="position: static; transform: none; color: #fff">${myPointsInt}</span>
                <span class="win_index_perc" style="color: #fff">.${myPointsDec}</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff">${oppPointsInt}</span>
                <span class="win_index_perc" style="color: #fff">.${oppPointsDec}</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="${badgeClass}">${badgeText}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else {
        // Layout di default per altri stati
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge">${contestData.status_display || 'READY'}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      }
      
      container.appendChild(contestCard);
    }

    // Renderizza le liste dei giocatori per ciascuna squadra
    function renderTeamLists(ownerTeam, opponentTeam, contestData) {
      const leftTeamList = document.getElementById("leftTeamList");
      const rightTeamList = document.getElementById("rightTeamList");
      leftTeamList.innerHTML = "";
      rightTeamList.innerHTML = "";

      // Determina se il current user è owner
      const isCurrentUserOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));

      if (isCurrentUserOwner) {
        // Se current user è owner, usa ownerTeam per la lista di sinistra e opponentTeam per quella di destra
        ownerTeam.forEach(player => {
          leftTeamList.appendChild(createPlayerRow(player, "left"));
        });
        opponentTeam.forEach(player => {
          rightTeamList.appendChild(createPlayerRow(player, "right"));
        });
      } else {
        // Se current user è opponent, inverte le liste
        opponentTeam.forEach(player => {
          leftTeamList.appendChild(createPlayerRow(player, "left"));
        });
        ownerTeam.forEach(player => {
          rightTeamList.appendChild(createPlayerRow(player, "right"));
        });
      }
    }

    // Crea una riga per un giocatore.
    // Il parametro "side" determina l'ordine dei blocchi: "left" per il current user, "right" per l'avversario (speculare).
    function createPlayerRow(player, side) {
      // Create a wrapper to contain both the player row and the separator
      const wrapper = document.createElement("div");
      
      // Crea il container per la riga
      const row = document.createElement("div");
      row.classList.add("player-row");
      
      // BLOCCO AVATAR: Immagine e posizione
      const avatarBlock = document.createElement("div");
      avatarBlock.classList.add("avatar-block");
      avatarBlock.style.position = "relative";
      
      // Create the athlete avatar container
      const avatarContainer = document.createElement("div");
      avatarContainer.classList.add("atheleteAvatar");
      
      // Create the image inside the container (will be 123% larger)
      const iconImg = document.createElement("img");
      iconImg.src = player.picture ? `pictures/${player.picture}` : `pictures/player_placeholder.png`;
      iconImg.onerror = function() {
        this.src = 'pictures/player_placeholder.png';
      };
      
      // Add the image to the avatar container
      avatarContainer.appendChild(iconImg);
      
      const posCircle = document.createElement("div");
      posCircle.classList.add("position_circle", player.position);
      posCircle.textContent = player.position;
      
      avatarBlock.appendChild(avatarContainer);
      avatarBlock.appendChild(posCircle);
      
      // BLOCCO INFO: Nome e match info
      const infoBlock = document.createElement("div");
      infoBlock.classList.add("player-info");
      
      const nameSpan = document.createElement("div");
      nameSpan.classList.add("athlete_shortname");
      nameSpan.textContent = player.athlete_shortname;
      
      const matchSpan = document.createElement("div");
      matchSpan.classList.add("match_3letter");
      matchSpan.innerHTML = `<span style="font-weight: 800;">${player.player_team_code || ''}</span> | CONC: <span style="font-weight: 800;">${player.aep_id || player.event_unit_id || ''}</span>`;
      
      infoBlock.appendChild(nameSpan);
      infoBlock.appendChild(matchSpan);
      
      // BLOCCO PUNTI & COSTO
      const pointsCostBlock = document.createElement("div");
      pointsCostBlock.classList.add("points-cost-block");
      
      const pointsContainer = document.createElement("div");
      pointsContainer.classList.add("points-container");
      
      // Se is_ended è 0, mostra 0.0 in grigio, altrimenti mostra i punti in bianco
      const isEnded = parseInt(player.is_ended) === 1;
      const points = parseFloat(player.athlete_points || 0).toFixed(1);
      const [pointsInt, pointsDec] = points.split('.');
      
      const pointsIntSpan = document.createElement("span");
      pointsIntSpan.classList.add("athlete_points_integer", isEnded ? "is_ended" : "not_ended");
      pointsIntSpan.textContent = pointsInt;
      
      const pointsDecSpan = document.createElement("span");
      pointsDecSpan.classList.add("athlete_points_decimal", isEnded ? "is_ended" : "not_ended");
      pointsDecSpan.textContent = `.${pointsDec}`;
      
      pointsContainer.appendChild(pointsIntSpan);
      pointsContainer.appendChild(pointsDecSpan);
      
      const costSpan = document.createElement("div");
      costSpan.classList.add("athlete_cost");
      costSpan.textContent = parseFloat(player.cost || 0).toFixed(1);
      
      pointsCostBlock.appendChild(pointsContainer);
      pointsCostBlock.appendChild(costSpan);
      
      // Ora, in base al lato, ordiniamo i blocchi:
      if (side === "left") {
        row.appendChild(avatarBlock);
        row.appendChild(infoBlock);
        row.appendChild(pointsCostBlock);
      } else {
        row.appendChild(pointsCostBlock);
        row.appendChild(infoBlock);
        row.appendChild(avatarBlock);
      }
      
      // Add the row to the wrapper
      wrapper.appendChild(row);
      
      // Add the separator line
      const separator = document.createElement("div");
      separator.classList.add("player-separator");
      wrapper.appendChild(separator);
      
      return wrapper;
    }

    window.addEventListener("DOMContentLoaded", () => {
      loadTeexBalance();
      loadContestDetails();
    });
  </script>
</body>
</html>
