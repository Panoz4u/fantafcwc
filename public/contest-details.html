<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Contest Details - Fanteex</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,800;1,800&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/mobile.css">
  <link rel="stylesheet" href="css/mobile2.css">
  <!-- Corretto il riferimento al file delle funzioni avatar -->
  <script src="/js/avatar-functions.js"></script>
</head>
<body>
  <!-- Header principale -->
  <header class="header">
    <div class="user-profile">
      <img src="icons/freccia.png" alt="Back" id="backArrow" style="width: 30px; height: 30px; cursor: pointer; margin-right: 12px;">
      <div class="user-info">
        <h1 class="user-name">MATCH DETAILS</h1>
      </div>
    </div>
    <div class="teex-balance">
       <img src="icons/ppc.png" alt="Teex" class="teex-icon">
      <span id="teexContainer" class="teex_balance">0.0</span>
    </div>


  </header>



  <!-- Messaggio di errore -->
  <div id="errorMessage" style="display: none; color: red; padding: 10px; margin: 10px; background-color: rgba(255, 0, 0, 0.1); border-radius: 5px;"></div>

  <div class="contest-container cc-header" id="contestHeaderContainer">
    <!-- Il contest verrà renderizzato qui -->
  </div>

  <!-- Blocco nomi utenti -->
  <div id="userNamesBlock" class="contest_usernames">
    <div id="leftUserName" class="full_username full_username_left"></div>
    <div id="rightUserName" class="full_username full_username_right"></div>
  </div>

  <!-- Sezione Teams: Liste dei giocatori -->
  <section class="teams-section">
    <!-- Lista Squadra Sinistra (utente corrente) -->
    <div class="team-container left-team" id="leftTeamContainer">
      <div class="team-list" id="leftTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
    <!-- Lista Squadra Destra (avversario) -->
    <div class="team-container right-team" id="rightTeamContainer">
      <div class="team-list" id="rightTeamList">
        <!-- I giocatori verranno renderizzati qui -->
      </div>
    </div>
  </section>

  <!-- Footer bar (semi-transparent, no icons) -->
  <!-- Footer bar with buttons aligned to the right
    <footer class="footer-nav" style="justify-content: flex-end; ">
      <button class="footer_button footer_button_blue">SHARE</button>
      <button class="footer_button footer_button_orange">REMATCH</button>
    </footer>
    -->
  <script>
    // Funzione per ottenere l'URL dell'avatar
    function getAvatarSrc(avatar, username, userColor) {
      if (avatar && avatar.trim() !== "") {
        if (avatar.startsWith("http")) {
          // Per gli URL di Google, assicuriamoci che non ci siano problemi di encoding
          if (avatar.includes("googleusercontent.com")) {
            // Decodifica l'URL per assicurarsi che non ci siano problemi di encoding
            return decodeURIComponent(avatar);
          }
          return avatar;
        } else {
          return "avatars/" + avatar;
        }
      } else {
        // Se non c'è avatar, generiamo un data URL con un cerchio colorato e le iniziali
        return generateColoredInitialsAvatar(username, userColor);
      }
    }

    // Funzione per generare un avatar colorato con le iniziali
    function generateColoredInitialsAvatar(username, color) {
      // Usa un colore predefinito se non è specificato
      const bgColor = color || "ff5500";
      
      // Ottieni le prime 3 lettere dello username (o meno se lo username è più corto)
      const initials = username ? username.substring(0, 3).toUpperCase() : "?";
      
      // Crea un canvas temporaneo
      const canvas = document.createElement("canvas");
      canvas.width = 200;
      canvas.height = 200;
      const ctx = canvas.getContext("2d");
      
      // Disegna il cerchio colorato
      ctx.fillStyle = "#" + bgColor;
      ctx.beginPath();
      ctx.arc(100, 100, 100, 0, Math.PI * 2);
      ctx.fill();
      
      // Imposta lo stile del testo
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 80px 'Barlow Condensed', sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      // Disegna le iniziali
      ctx.fillText(initials, 100, 100);
      
      // Converti il canvas in un data URL
      return canvas.toDataURL("image/png");
    }

    // Legge i parametri dal localStorage invece che dalla query string
    const contestId = localStorage.getItem("contestId");
    const currentUserId = localStorage.getItem("userId");
    const eventUnitId = localStorage.getItem("eventUnitId");
    const authToken = localStorage.getItem("authToken");
    const ownerId = localStorage.getItem("ownerId");
    const opponentId = localStorage.getItem("opponentId");

    console.log("Parametri caricati dal localStorage:", {
      contestId,
      currentUserId,
      eventUnitId,
      authToken,
      ownerId,
      opponentId
    });

    // Carica il Teex balance
    async function loadTeexBalance() {
      try {
        const resp = await fetch("/user-landing-info", {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        if (resp.ok) {
          const data = await resp.json();
          const teexContainer = document.getElementById("teexContainer");
          if (teexContainer) {
            teexContainer.textContent = parseFloat(data.user.teex_balance).toFixed(1);
          }
        } else {
          const teexContainer = document.getElementById("teexContainer");
          if (teexContainer) {
            teexContainer.textContent = "0.0";
          }
        }
      } catch (error) {
        console.error("Error loading teex balance:", error);
        const teexContainer = document.getElementById("teexContainer");
        if (teexContainer) {
          teexContainer.textContent = "0.0";
        }
      }
    }

    // Click sulla freccia torna alla landing
    document.getElementById("backArrow").addEventListener("click", () => {
      window.location.href = "/user-landing.html";
    });

    // Carica i dettagli del contest
    async function loadContestDetails() {
      try {
        if (!contestId || !authToken) {
          console.error("Parametri mancanti: contestId o authToken");
          showError("Parametri mancanti. Torna alla pagina precedente.");
          return;
        }
        
        // Recupera ownerId e opponentId dal localStorage
        const ownerId = localStorage.getItem("ownerId");
        const opponentId = localStorage.getItem("opponentId");
        
        console.log("Owner ID:", ownerId);
        console.log("Opponent ID:", opponentId);
        
        // Assicurati che entrambi i valori siano presenti
        if (!ownerId || !opponentId) {
          console.error("Parametri mancanti: ownerId o opponentId");
          showError("Informazioni utente mancanti. Torna alla pagina precedente.");
          return;
        }
        
        // Prepara i dati da inviare
        const requestData = {
          contest_id: parseInt(contestId),
          owner_id: parseInt(ownerId),
          opponent_id: parseInt(opponentId)
        };
        
        console.log("Dati inviati al server:", JSON.stringify(requestData));
        
        // Effettua la richiesta al server
        const resp = await fetch("/contests/contest-details", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${authToken}`
          },
          body: JSON.stringify(requestData)
        });
        
        console.log("Risposta del server:", resp.status, resp.statusText);
        
        if (!resp.ok) {
          const errorText = await resp.text();
          let errorData;
          try {
            errorData = JSON.parse(errorText);
            console.log("Errore JSON completo:", errorData);
          } catch (e) {
            errorData = { error: errorText };
            console.log("Errore testo completo:", errorText);
          }
          
          console.error("Errore caricamento dettagli:", resp.status, errorData);
          
          // Crea l'elemento errorMessage se non esiste
          let errorMessage = document.getElementById("errorMessage");
          if (!errorMessage) {
            errorMessage = document.createElement("div");
            errorMessage.id = "errorMessage";
            errorMessage.style.color = "red";
            errorMessage.style.padding = "10px";
            errorMessage.style.margin = "10px";
            errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
            errorMessage.style.borderRadius = "5px";
            document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
          }
          
          errorMessage.textContent = `Errore: ${errorData.error || "Impossibile caricare i dettagli"}`;
          errorMessage.style.display = "block";
          return;
        }
        
        // Corretto: usa resp invece di response
        const data = await resp.json();
        console.log("Contest data:", data);
        
        // Verifica che i dati necessari esistano
        if (!data.contest) {
          console.error("Dati del contest mancanti nella risposta");
          let errorMessage = document.getElementById("errorMessage");
          if (!errorMessage) {
            errorMessage = document.createElement("div");
            errorMessage.id = "errorMessage";
            errorMessage.style.color = "red";
            errorMessage.style.padding = "10px";
            errorMessage.style.margin = "10px";
            errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
            errorMessage.style.borderRadius = "5px";
            document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
          }
          errorMessage.textContent = "Dati del contest mancanti nella risposta";
          errorMessage.style.display = "block";
          return;
        }
        
        console.log("Contest status:", data.contest.status);
        if (data.contest.fantasy_teams) {
          console.log("Fantasy teams:", data.contest.fantasy_teams);
        }
        
        // Popola i nomi nel blocco sotto il contest header
        const iAmOwner = (parseInt(currentUserId) === parseInt(data.contest.owner_id));
        
        const leftUserName = document.getElementById("leftUserName");
        const rightUserName = document.getElementById("rightUserName");
        
        if (leftUserName && rightUserName) {
          if (iAmOwner) {
            leftUserName.textContent = data.contest.owner_name;
            rightUserName.textContent = data.contest.opponent_name;
          } else {
            leftUserName.textContent = data.contest.opponent_name;
            rightUserName.textContent = data.contest.owner_name;
          }
        }
        
        // Renderizza l'header del contest usando lo stesso layout di user-landing.html
        renderContestHeader(data.contest);
        
        // Renderizza le liste dei giocatori
        if (typeof renderTeamLists === 'function') {
          renderTeamLists(data.ownerTeam, data.opponentTeam, data.contest);
        } else {
          console.warn("La funzione renderTeamLists non è definita");
        }
      } catch (error) {
        console.error("Error loading contest details", error);
        
        // Crea l'elemento errorMessage se non esiste
        let errorMessage = document.getElementById("errorMessage");
        if (!errorMessage) {
          errorMessage = document.createElement("div");
          errorMessage.id = "errorMessage";
          errorMessage.style.color = "red";
          errorMessage.style.padding = "10px";
          errorMessage.style.margin = "10px";
          errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
          errorMessage.style.borderRadius = "5px";
          document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
        }
        
        errorMessage.textContent = "Si è verificato un errore durante il caricamento dei dettagli.";
        errorMessage.style.display = "block";
      }
    }

    // Renderizza l'header del contest usando lo stesso layout di user-landing.html
    function renderContestHeader(contestData) {
      const container = document.getElementById("contestHeaderContainer");
      container.innerHTML = "";
      
      // Determina se il current user è owner
      const iAmOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));
      
      let myName, myAvatar, myCost, oppName, oppAvatar, oppCost;
      if (iAmOwner) {
        myName = contestData.owner_name;
        myAvatar = contestData.owner_avatar;
        myCost = contestData.owner_cost || "-";
        oppName = contestData.opponent_name;
        oppAvatar = contestData.opponent_avatar;
        oppCost = contestData.opponent_cost || "-";
      } else {
        myName = contestData.opponent_name;
        myAvatar = contestData.opponent_avatar;
        myCost = contestData.opponent_cost || "-";
        oppName = contestData.owner_name;
        oppAvatar = contestData.owner_avatar;
        oppCost = contestData.owner_cost || "-";
      }
      
      // Crea la card del contest
      const contestCard = document.createElement("div");
      contestCard.classList.add("contest-cell");
      
      // Determina il layout in base allo stato del contest
      if (contestData.status == 1 && iAmOwner) {
        // Layout per contest in stato "pending" dove sono il proprietario
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">-</div>
            </div>
            <div class="status-badge-base status-badge">PENDING</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 1 && !iAmOwner) {
        // Layout per contest in stato "invited" dove sono l'invitato
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">-</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-invited">INVITED</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 2) {
        // Layout per contest in stato "ready"
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-ready">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 4) {
        // Layout per contest in stato "in progress"
        let leftScore = 0;
        let rightScore = 0;
        
        // Use the result field directly from contestData without swapping
        if (contestData.result) {
          const parts = contestData.result.split('-');
          if (parts.length === 2) {
            // Always use the result in the exact order it comes from the server
            leftScore = parseFloat(parts[0]) || 0;
            rightScore = parseFloat(parts[1]) || 0;
          }
        }
        
        const leftScoreStr = leftScore.toFixed(1);
        const rightScoreStr = rightScore.toFixed(1);
        
        const [leftScoreInt, leftScoreDec = "0"] = leftScoreStr.split('.');
        const [rightScoreInt, rightScoreDec = "0"] = rightScoreStr.split('.');
        
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div style="position: absolute; top: calc(50% - 14px); left: 50%; transform: translate(-50%, -50%); display: flex; align-items: baseline;">
                <span class="result_bold" style="position: static; transform: none; color: #fff">${leftScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${leftScoreDec}</span>
                <span style="margin: 0 5px; color: white; font-size: 20px;"> </span>
                <span class="result_bold" style="position: static; transform: none; color: #fff">${rightScoreInt}</span>
                <span class="win_index_perc" style="color: #fff">.${rightScoreDec}</span>
              </div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-live">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else if (contestData.status == 5) {
        // Layout per contest in stato "completed"
        // Ottieni i punteggi dai total_points dei fantasy_teams
        let myPoints = 0;
        let oppPoints = 0;
        let myResult = 0;
        let myTeexWon = 0;
        
        // Estrai i dati dai fantasy_teams
        if (contestData.fantasy_teams && contestData.fantasy_teams.length > 0) {
          contestData.fantasy_teams.forEach(team => {
            if ((iAmOwner && team.user_id == contestData.owner_id) || 
                (!iAmOwner && team.user_id == contestData.opponent_id)) {
              myPoints = parseFloat(team.total_points || 0);
              myResult = parseInt(team.ft_result || 0);
              myTeexWon = parseFloat(team.ft_teex_won || 0);
            } else {
              oppPoints = parseFloat(team.total_points || 0);
            }
          });
        }
        
        const myPointsStr = myPoints.toFixed(1);
        const oppPointsStr = oppPoints.toFixed(1);
        
        const [myPointsInt, myPointsDec = "0"] = myPointsStr.split('.');
        const [oppPointsInt, oppPointsDec = "0"] = oppPointsStr.split('.');
        
        // Determina lo stile del badge in base al risultato
        let badgeClass = "status-badge-live";
        let badgeText = "";
        
        if (myResult === 1) {
          // Vittoria
          badgeClass = "status-badge-base status-badge-win"; // Sfondo verde
          badgeText = `+${myTeexWon.toFixed(1)}`;
        } else if (myResult === -1) {
          // Sconfitta
          badgeClass = "status-badge-base status-badge-loss"; // Sfondo fucsia
          badgeText = `${myTeexWon.toFixed(1)}`; // Il valore è già negativo
        } else {
          // Pareggio
          badgeClass = "status-badge-base status-badge-draw"; // Sfondo arancione
          badgeText = myTeexWon >= 0 ? `+${myTeexWon.toFixed(1)}` : `${myTeexWon.toFixed(1)}`;
        }
        
        // Esempio di modifica per una chiamata a getAvatarSrc
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar, myName, myColor)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar, oppName, oppColor)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge-ready">${contestData.stake || ''}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      } else {
        // Layout di default per altri stati
        contestCard.innerHTML = `
          <div class="contest-container cc-header">
            <div class="contest-bar">
              <img src="${getAvatarSrc(myAvatar)}" alt="${myName}" class="player-avatar-contest left-avatar">
              <div class="triletter_contest left-name">${myName.substring(0, 3)}</div>
              <div class="result_bold">VS</div>
              <div class="triletter_contest right-name">${oppName.substring(0, 3)}</div>
              <img src="${getAvatarSrc(oppAvatar)}" alt="${oppName}" class="player-avatar-contest right-avatar">
              <div class="teex_spent left-teex">${myCost}</div>
              <div class="teex_spent right-teex">${oppCost}</div>
            </div>
            <div class="status-badge-base status-badge">${contestData.status_display || 'READY'}</div>
            ${contestData.multiply && parseInt(contestData.multiply) > 1 ? `<div class="multiply-contest-mini">${Math.floor(contestData.multiply)}</div>` : ''}
          </div>
        `;
      }
      
      container.appendChild(contestCard);
    }

    // Renderizza le liste dei giocatori per ciascuna squadra
    function renderTeamLists(ownerTeam, opponentTeam, contestData) {
      const leftTeamList = document.getElementById("leftTeamList");
      const rightTeamList = document.getElementById("rightTeamList");
      leftTeamList.innerHTML = "";
      rightTeamList.innerHTML = "";

      // Determina se il current user è owner
      const isCurrentUserOwner = (parseInt(currentUserId) === parseInt(contestData.owner_id));

      if (isCurrentUserOwner) {
        // Se current user è owner, usa ownerTeam per la lista di sinistra e opponentTeam per quella di destra
        ownerTeam.forEach(player => {
          leftTeamList.appendChild(createPlayerRow(player, "left"));
        });
        opponentTeam.forEach(player => {
          rightTeamList.appendChild(createPlayerRow(player, "right"));
        });
      } else {
        // Se current user è opponent, inverte le liste
        opponentTeam.forEach(player => {
          leftTeamList.appendChild(createPlayerRow(player, "left"));
        });
        ownerTeam.forEach(player => {
          rightTeamList.appendChild(createPlayerRow(player, "right"));
        });
      }
    }

    // Crea una riga per un giocatore.
    // Il parametro "side" determina l'ordine dei blocchi: "left" per il current user, "right" per l'avversario (speculare).
    function createPlayerRow(player, side) {
      // Create a wrapper to contain both the player row and the separator
      const wrapper = document.createElement("div");
      
      // Crea il container per la riga
      const row = document.createElement("div");
      row.classList.add("player-row");
      
      // BLOCCO AVATAR: Immagine e posizione
      const avatarBlock = document.createElement("div");
      avatarBlock.classList.add("avatar-block");
      avatarBlock.style.position = "relative";
      
      // Create the athlete avatar container
      const avatarContainer = document.createElement("div");
      avatarContainer.classList.add("atheleteAvatar");
      
      // Create the image inside the container (will be 123% larger)
      const iconImg = document.createElement("img");
      iconImg.src = player.picture ? `pictures/${player.picture}` : `pictures/player_placeholder.png`;
      iconImg.onerror = function() {
        this.src = 'pictures/player_placeholder.png';
      };
      
      // Add the image to the avatar container
      avatarContainer.appendChild(iconImg);
      
      const posCircle = document.createElement("div");
      posCircle.classList.add("position_circle", player.position);
      posCircle.textContent = player.position;
      
      avatarBlock.appendChild(avatarContainer);
      avatarBlock.appendChild(posCircle);
      
      // BLOCCO INFO: Nome e match info
      const infoBlock = document.createElement("div");
      infoBlock.classList.add("player-info");
      
      const nameSpan = document.createElement("div");
      nameSpan.classList.add("athlete_shortname");
      nameSpan.textContent = player.athlete_shortname;
      
      const matchSpan = document.createElement("div");
      matchSpan.classList.add("match_3letter");
      // ID unico per lo span che conterrà l'event_unit_id
      const eventUnitSpanId = `event-unit-${player.aep_id}`;
      matchSpan.innerHTML = `<span style="font-weight: 800;">${player.player_team_code || ''}</span> | CC: <span style="font-weight: 800;" id="${eventUnitSpanId}">...</span>`;
      
      // Se c'è l'aep_id, chiama l'endpoint per ottenere l'event_unit_id
      if (player.aep_id) {
        fetch(`/aep-event-unit?aep_id=${player.aep_id}`)
          .then(res => res.json())
          .then(data => {
            if (data.event_unit_id) {
              const span = document.getElementById(eventUnitSpanId);
              if (span) span.textContent = data.event_unit_id;
            }
          })
          .catch(() => {
            const span = document.getElementById(eventUnitSpanId);
            if (span) span.textContent = "-";
          });
      }
      infoBlock.appendChild(nameSpan);
      infoBlock.appendChild(matchSpan);
      
      // BLOCCO PUNTI & COSTO
      const pointsCostBlock = document.createElement("div");
      pointsCostBlock.classList.add("points-cost-block");
      
      const pointsContainer = document.createElement("div");
      pointsContainer.classList.add("points-container");
      
      // Se is_ended è 0, mostra 0.0 in grigio, altrimenti mostra i punti in bianco
      const isEnded = parseInt(player.is_ended) === 1;
      const points = parseFloat(player.athlete_points || 0).toFixed(1);
      const [pointsInt, pointsDec] = points.split('.');
      
      const pointsIntSpan = document.createElement("span");
      pointsIntSpan.classList.add("athlete_points_integer", isEnded ? "is_ended" : "not_ended");
      pointsIntSpan.textContent = pointsInt;
      
      const pointsDecSpan = document.createElement("span");
      pointsDecSpan.classList.add("athlete_points_decimal", isEnded ? "is_ended" : "not_ended");
      pointsDecSpan.textContent = `.${pointsDec}`;
      
      pointsContainer.appendChild(pointsIntSpan);
      pointsContainer.appendChild(pointsDecSpan);
      
      const costSpan = document.createElement("div");
      costSpan.classList.add("athlete_cost");
      costSpan.textContent = parseFloat(player.cost || 0).toFixed(1);
      
      pointsCostBlock.appendChild(pointsContainer);
      pointsCostBlock.appendChild(costSpan);
      
      // Ora, in base al lato, ordiniamo i blocchi:
      if (side === "left") {
        row.appendChild(avatarBlock);
        row.appendChild(infoBlock);
        row.appendChild(pointsCostBlock);
      } else {
        row.appendChild(pointsCostBlock);
        row.appendChild(infoBlock);
        row.appendChild(avatarBlock);
      }
      
      // Add the row to the wrapper
      wrapper.appendChild(row);
      
      // Add the separator line
      const separator = document.createElement("div");
      separator.classList.add("player-separator");
      wrapper.appendChild(separator);
      
      return wrapper;
    }

    // Aggicurati che il DOM sia completamente caricato prima di eseguire le funzioni
    document.addEventListener("DOMContentLoaded", async () => {
      try {
        // Carica il teex balance
        await loadTeexBalance();
        
        // Carica i dettagli del contest
        await loadContestDetails();
        
        // Click sulla freccia torna alla landing
        const backArrow = document.getElementById("backArrow");
        if (backArrow) {
          backArrow.addEventListener("click", () => {
            window.location.href = "/user-landing.html";
          });
        }
      } catch (error) {
        console.error("Errore durante il caricamento della pagina:", error);
        
        // Funzione per mostrare messaggi di errore
        function showError(message) {
          let errorMessage = document.getElementById("errorMessage");
          if (!errorMessage) {
            errorMessage = document.createElement("div");
            errorMessage.id = "errorMessage";
            errorMessage.style.color = "red";
            errorMessage.style.padding = "10px";
            errorMessage.style.margin = "10px";
            errorMessage.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
            errorMessage.style.borderRadius = "5px";
            document.body.insertBefore(errorMessage, document.querySelector("section.teams-section"));
          }
          errorMessage.textContent = message;
          errorMessage.style.display = "block";
        }
        
        errorMessage.textContent = "Si è verificato un errore durante il caricamento della pagina.";
        errorMessage.style.display = "block";
      }
    });
  </script>
</body>
</html>
