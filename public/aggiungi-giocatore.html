<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Aggiungi Giocatore</title>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,400;0,800;1,800&family=Barlow+Condensed:wght@400;700&display=swap" rel="stylesheet">
   <link rel="stylesheet" href="css/mobile2.css">
  <link rel="stylesheet" href="css/mobile.css">
  <style>
 /* Stile per il pulsante di cancellazione della ricerca */
 .clear-search {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      cursor: pointer;
      z-index: 10;
      background-image: url('icons/searchclose.png');
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      display: none; /* Nascosto di default */
    }
    


  </style>
</head>
<body>
  <!-- Header -->

  <header class="header">
    <div class="user-profile">
      <img src="icons/freccia.png" alt="Back" id="backArrow" style="width: 30px; height: 30px; cursor: pointer; margin-right: 12px;">
      <div class="user-info">
        <h1 class="user-name">ADD ARTISTS</h1>
      </div>
    </div>
    
    <!-- New header right section with player stats -->
    <div class="header-stats">
      <div class="stats-row">
        <div class="label_m_small">ARTISTS</div>
        <div class="label_m_small">Cost</div>
        <div class="label_m_small">PPC left</div>
      </div>
      <div class="stats-values">
        <div class="square_cont_color scc_petrolio" id="playersCount">12</div>
        <div class="square_cont_color scc_cyan" id="totalCost">19.5</div>
        <div class="square_cont_color scc_porpora" id="teexLeft">0.5</div>
      </div>
    </div>
  </header>

  <!-- Search box -->
  <div class="search-container">
    <span class="search-icon">üîç</span>
    <input type="text" id="searchInput" class="search-box" placeholder="Search by: Name, Surname, Country, Conclave">
    <span class="clear-search" id="clearSearch"></span>
  </div>

  <!-- Sort header -->
  <div class="sort-header">
    <div class="sort-item active" data-sort="name">
      Name
      <div class="sort-triangle asc"></div>
    </div>
    <div class="sort-item" data-sort="team">Country</div>
    <div class="sort-item" data-sort="cost">Cost</div>
  </div>

  <div id="msg"></div>
  <ul id="playerList" class="player-list"></ul>



  <!-- Footer bar with ADD TO TEAM button -->
  <footer class="footer-nav" style="justify-content: center;">
    <button id="addToTeamBtn" class="footer_button fb_unable_orange" disabled>UPDATE TEAM</button>
  </footer>

  <script>
    // Add a new array to store temporarily selected players
    let tempSelectedPlayers = [];
    
    function loadChosenPlayers() {
      let c = localStorage.getItem("chosenPlayers");
      if(!c) return [];
      try { return JSON.parse(c); } catch{ return []; }
    }
    
    function saveChosenPlayers(list) {
      localStorage.setItem("chosenPlayers", JSON.stringify(list));
    }
    
    function getAvailableBudget() {
      const players = loadChosenPlayers();
      const totalCost = players.reduce((acc,p)=>acc+parseFloat(p.event_unit_cost||0),0);
      return Math.max(0, 10-totalCost);
    }

    function getTotalCost() {
      const players = loadChosenPlayers();
      return players.reduce((acc,p)=>acc+parseFloat(p.event_unit_cost||0),0);
    }

    function updateHeaderStats() {
      const players = loadChosenPlayers();
      const playerCount = players.length;
      const totalCost = getTotalCost();
      const teexLeft = getAvailableBudget();
      
      // Calculate temporary selections - only count additions and removals once
      const tempAdditions = tempSelectedPlayers.filter(p => !p.isRemoval).length;
      const tempRemovals = tempSelectedPlayers.filter(p => p.isRemoval).length;
      
      // Calculate the net change in player count
      const tempPlayerCount = tempAdditions - tempRemovals;
      
      // Calculate cost changes
      const tempAdditionsCost = tempSelectedPlayers.filter(p => !p.isRemoval)
        .reduce((acc,p) => acc + parseFloat(p.event_unit_cost || 0), 0);
      const tempRemovalsCost = tempSelectedPlayers.filter(p => p.isRemoval)
        .reduce((acc,p) => acc + parseFloat(p.event_unit_cost || 0), 0);
      const tempTotalCost = tempAdditionsCost - tempRemovalsCost;
      
      // Update the header stats with combined values
      document.getElementById('playersCount').textContent = playerCount + tempPlayerCount;
      document.getElementById('totalCost').textContent = (totalCost + tempTotalCost).toFixed(1);
      document.getElementById('teexLeft').textContent = Math.max(0, teexLeft - tempAdditionsCost + tempRemovalsCost).toFixed(1);
      
      // Update Add to Team button state
      const addToTeamBtn = document.getElementById('addToTeamBtn');
      if (tempSelectedPlayers.length > 0) {
        addToTeamBtn.className = "footer_button footer_button_orange";
        addToTeamBtn.disabled = false;
      } else {
        addToTeamBtn.className = "footer_button fb_unable_orange";
        addToTeamBtn.disabled = true;
      }
    }

    // Function to toggle player selection
    function togglePlayerSelection(player, element) {
      // Creiamo un ID univoco combinando athlete_id e event_unit_id
      const uniqueId = `${player.athlete_id}_${player.event_unit_id}`;
      
      // Check if player is already in temp selection usando l'ID univoco
      const index = tempSelectedPlayers.findIndex(p => 
        `${p.athlete_id}_${p.event_unit_id}` === uniqueId);
      
      if (index === -1) {
        // Add to temp selection
        // Assicuriamoci che aep_id sia incluso nell'oggetto player
        if (!player.aep_id) {
          console.warn(`Atleta ${player.athlete_shortname} (ID: ${player.athlete_id}) non ha aep_id, utilizzo athlete_id come fallback`);
          player.aep_id = player.athlete_id;
        } else {
          console.log(`Atleta ${player.athlete_shortname} ha aep_id: ${player.aep_id}`);
        }
        
        console.log("Aggiunto giocatore con aep_id:", player.aep_id);
        tempSelectedPlayers.push(player);
        element.style.backgroundColor = "#0f7173";
      } else {
        // Remove from temp selection
        tempSelectedPlayers.splice(index, 1);
        element.style.backgroundColor = "rgba(255, 255, 255, 0.05)"; // Reset background
      }
      
      // Update header stats
      updateHeaderStats();
      
      // Re-render all players to update affordability
      filterAndRenderPlayers();
    }

    // Function to update the ADD TO TEAM button state
    function updateAddToTeamButton() {
      const addToTeamBtn = document.getElementById('addToTeamBtn');
      if (tempSelectedPlayers.length > 0) {
        addToTeamBtn.disabled = false;
        addToTeamBtn.classList.remove('fb_unable_orange');
        addToTeamBtn.classList.add('fb_orange');
      } else {
        addToTeamBtn.disabled = true;
        addToTeamBtn.classList.add('fb_unable_orange');
        addToTeamBtn.classList.remove('fb_orange');
      }
    }
    
    // Function to add all temp selected players to the team
    function addTempPlayersToTeam() {
      const chosenPlayers = loadChosenPlayers();
      
      // Process removals first
      const removals = tempSelectedPlayers.filter(p => p.isRemoval);
      const additions = tempSelectedPlayers.filter(p => !p.isRemoval);
      
      // Remove players marked for removal
      const updatedChosenPlayers = chosenPlayers.filter(chosen => 
        !removals.some(removal => removal.athlete_id === chosen.athlete_id)
      );
      
      // Add new selections
      const finalPlayerList = [...updatedChosenPlayers, ...additions];
      
      // Save to localStorage
      saveChosenPlayers(finalPlayerList);
      
      // Clear temp selections
      tempSelectedPlayers = [];
      
      // Update button state
      updateAddToTeamButton();
      
      // Redirect back to team summary
      window.location.href = 'riassunto.html';
    }

    const params = new URLSearchParams(window.location.search);
    let ownerId = params.get("owner");
    let opponentId = params.get("opponent");
    let contestId = params.get("contest");
    let userId = params.get("user");
    // Rimuoviamo il riferimento a event_unit_id
    // const eventUnitId = params.get("event_unit_id") || 1;
    // const eventId = params.get("event") || 30;
    // const eventUnitId = params.get("event_unit_id") || 32;

    // Sorting state
    let currentSort = {
      field: 'name',
      direction: 'asc'
    };
    
    // Search state
    let searchTerm = '';
    let allPlayers = [];

    document.addEventListener("DOMContentLoaded", () => {
      try {
        // Prova a recuperare i dati dal localStorage
        const addPlayerDataStr = localStorage.getItem('addPlayerData');
        
        if (addPlayerDataStr) {
          // Se abbiamo dati nel localStorage, usiamo quelli
          const addPlayerData = JSON.parse(addPlayerDataStr);
          
          // Verifica che i dati non siano troppo vecchi
          const now = new Date().getTime();
          const dataAge = now - (addPlayerData.timestamp || 0);
          const maxAge = 5 * 60 * 1000; // 5 minuti
          
          if (dataAge <= maxAge) {
            // Assegna i valori alle variabili
            ownerId = addPlayerData.owner;
            opponentId = addPlayerData.opponent;
            contestId = addPlayerData.contest;
            userId = addPlayerData.user;
            
            // Aggiorna il teexBalance nell'header se disponibile
            const teexBalance = addPlayerData.teexBalance || "0.0";
            const teexBalanceEl = document.getElementById("teexBalance");
            if (teexBalanceEl) {
              teexBalanceEl.textContent = teexBalance;
            }
          } else {
            console.warn("I dati nel localStorage sono scaduti");
            // Non rimuoviamo i dati, potrebbero essere utili per debug
          }
        }
        
        // Se non abbiamo dati nel localStorage, proviamo a recuperarli dall'URL
        if (!ownerId || !contestId || !userId) {
          const params = new URLSearchParams(window.location.search);
          ownerId = params.get("owner");
          opponentId = params.get("opponent");
          contestId = params.get("contest");
          userId = params.get("user");
        }
        
        // Add back button functionality
        document.getElementById('backArrow').addEventListener('click', () => {
          // Navigate back to riassunto.html senza parametri
          window.location.href = '/riassunto.html';
        });
        
        // Add event listener for Add to Team button
        document.getElementById('addToTeamBtn').addEventListener('click', addTempPlayersToTeam);
        
        // Update header stats
        updateHeaderStats();
        
        // Add event listener to search box
        document.querySelector('.search-box').addEventListener('input', (e) => {
          searchTerm = e.target.value.toLowerCase().trim();
          
          // Normalizza il termine di ricerca rimuovendo accenti e caratteri speciali
          searchTerm = searchTerm.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
          
          filterAndRenderPlayers();
        });
        
        loadPlayers();
      } catch (error) {
        console.error("Errore nell'inizializzazione:", error);
        document.getElementById("msg").innerHTML = `
          <div style="color: #ff6b6b; padding: 10px; text-align: center;">
            <p>Errore nell'inizializzazione: ${error.message}</p>
            <p>Ricarica la pagina o torna alla home.</p>
          </div>`;
      }
    });

    // Add event listeners to sort headers
    document.querySelectorAll('.sort-item').forEach(item => {
      item.addEventListener('click', () => {
        const sortField = item.dataset.sort;
        
        // Toggle direction if clicking the same field
        if (currentSort.field === sortField) {
          currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
          currentSort.field = sortField;
          currentSort.direction = 'asc';
        }
        
        // Update UI to show active sort
        document.querySelectorAll('.sort-item').forEach(el => {
          el.classList.remove('active');
          el.querySelector('.sort-triangle')?.remove();
        });
        
        item.classList.add('active');
        
        const triangle = document.createElement('div');
        triangle.className = `sort-triangle ${currentSort.direction}`;
        item.appendChild(triangle);
        
        // Re-render players with new sort
        filterAndRenderPlayers();
      });
    });

    // Aggiungi questa funzione dopo loadPlayers()
    // Modifica questa funzione per gestire meglio gli errori
    async function testEventUnitExistence() {
      try {
        // Questa funzione non √® pi√π necessaria
        console.log("Funzione testEventUnitExistence non pi√π necessaria");
        return true;
      } catch (error) {
        console.error("Errore:", error);
        return false;
      }
    }
    
    // Semplifica questa funzione per non dipendere da API che non esistono
    async function getAvailableEvents() {
      try {
        // Utilizziamo un endpoint esistente o un valore predefinito
        const defaultEvents = [
          { id: 30, name: "Serie A - Giornata 1" },
          { id: 31, name: "Serie A - Giornata 2" }
        ];
        
        return defaultEvents;
      } catch (error) {
        console.error('Errore nel recupero degli eventi:', error);
        return [];
      }
    }
    
    // Modifica la funzione loadPlayers() per gestire meglio gli errori
    async function loadPlayers() {
      try {
        console.log("Caricamento di tutti gli atleti attivi");
        document.getElementById("msg").textContent = "Caricamento giocatori in corso...";
        
        // Utilizziamo il nuovo endpoint che non richiede event_unit_id
        const response = await fetch(`/all-active-athletes`);
        if (!response.ok) {
          throw new Error("Errore nel caricamento dei giocatori");
        }
        
        const data = await response.json();
        console.log(`Caricati ${data.length} giocatori attivi`);
        
        // Aggiungiamo un log per vedere la struttura del primo giocatore
        if (data.length > 0) {
          console.log("Struttura del primo giocatore:", JSON.stringify(data[0], null, 2));
          console.log("Propriet√† del primo giocatore:", Object.keys(data[0]));
          
          // Nuovo log per verificare specificamente il campo aep.id
          console.log("Verifica campo aep.id:", data[0].id);
          
          // Verifica se tutti i giocatori hanno il campo id
          const giocatoriSenzaId = data.filter(player => player.id === undefined).length;
          console.log(`Numero di giocatori senza campo id: ${giocatoriSenzaId} su ${data.length} totali`);
        }

        allPlayers = data;
        
        if (allPlayers.length === 0) {
          document.getElementById("msg").textContent = "Nessun giocatore attivo trovato";
        } else {
          document.getElementById("msg").textContent = "";
          filterAndRenderPlayers();
        }
      } catch (error) {
        console.error("Errore nel caricamento dei giocatori:", error);
        document.getElementById("msg").innerHTML = `
          <div style="color: #ff6b6b; padding: 10px; text-align: center;">
            <p>Impossibile caricare i giocatori: ${error.message}</p>
            <p>Verifica la connessione o contatta l'amministratore.</p>
          </div>`;
      }
    }
    
    // Rimuoviamo la funzione testEventUnitExistence() poich√© non √® pi√π necessaria
    
    // Modifica la funzione filterAndRenderPlayers() per filtrare in base al termine di ricerca
    function filterAndRenderPlayers() {
      if (!allPlayers || allPlayers.length === 0) {
        document.getElementById("msg").textContent = "Nessun giocatore disponibile";
        return;
      }
      
      // Filtra i giocatori in base al termine di ricerca
      let filteredPlayers = allPlayers;
      
      if (searchTerm) {
        filteredPlayers = allPlayers.filter(player => {
          // Normalizza i campi di testo per la ricerca
          const name = (player.athlete_shortname || '').toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
          const country = (player.country_name || '').toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
          const team = (player.player_team_code || '').toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
          
          return name.includes(searchTerm) || 
                 country.includes(searchTerm) || 
                 team.includes(searchTerm);
        });
      }
      
      // Ordina i giocatori e assegna il risultato a filteredPlayers
      filteredPlayers = sortPlayers(filteredPlayers, currentSort.field, currentSort.direction);
      
      // Renderizza i giocatori
      renderPlayers(filteredPlayers);
    }

    function sortPlayers(players, field, direction) {
      // Crea una copia dell'array per non modificare l'originale
      return players.slice().sort((a, b) => {
        let valueA, valueB;
        
        switch(field) {
          case 'position':
            valueA = a.position || '';
            valueB = b.position || '';
            break;
          case 'name':
            valueA = a.athlete_shortname || '';
            valueB = b.athlete_shortname || '';
            break;
          case 'match':
            // Modifica per ordinare per event_unit_id invece che per match
            valueA = a.event_unit_id || 0;
            valueB = b.event_unit_id || 0;
            // Converti in numeri per un ordinamento numerico corretto
            return direction === 'asc' ? valueA - valueB : valueB - valueA;
          case 'team':
            valueA = a.player_team_code || '';
            valueB = b.player_team_code || '';
            break;
          case 'cost':
            valueA = parseFloat(a.event_unit_cost || 0);
            valueB = parseFloat(b.event_unit_cost || 0);
            return direction === 'asc' ? valueA - valueB : valueB - valueA;
          default:
            valueA = a.athlete_shortname || '';
            valueB = b.athlete_shortname || '';
        }
        
        if (typeof valueA === 'string' && typeof valueB === 'string') {
          return direction === 'asc' 
            ? valueA.localeCompare(valueB) 
            : valueB.localeCompare(valueA);
        }
        
        return 0;
      });
    }

    function renderPlayers(players) {
      const playerList = document.getElementById('playerList');
      playerList.innerHTML = '';
      
      // Debug: log dei giocatori che stiamo per renderizzare
      console.log("Rendering players:", players.map(p => p.athlete_shortname));
      
      // Get already chosen players to mark them as selected
      const chosenPlayers = loadChosenPlayers();
      
      // Modifica qui: invece di confrontare solo l'athlete_id, confrontiamo la combinazione di athlete_id e event_unit_id
      const chosenPlayerUniqueIds = chosenPlayers.map(p => `${p.athlete_id}_${p.event_unit_id}`);
      
      // Calculate available budget considering both chosen and temp selected players
      const tempAdditionsCost = tempSelectedPlayers.filter(p => !p.isRemoval)
        .reduce((acc,p) => acc + parseFloat(p.event_unit_cost || 0), 0);
      const tempRemovalsCost = tempSelectedPlayers.filter(p => p.isRemoval)
        .reduce((acc,p) => acc + parseFloat(p.event_unit_cost || 0), 0);
      
      // Calculate current available budget
      const availableBudget = getAvailableBudget() - tempAdditionsCost + tempRemovalsCost;
      
      // Aggiungiamo un contatore per tracciare quanti giocatori vengono effettivamente renderizzati
      let renderedCount = 0;
      
      players.forEach(player => {
        // Skip players whose matches are in status 4 or 5 (completed)
        if (player.match_status && player.match_status >= 9) {
          console.log(`Skipping player ${player.athlete_shortname} - match status: ${player.match_status}`);
          return;
        }
        
        const playerCost = parseFloat(player.event_unit_cost || 0);
        
        // Creiamo un ID univoco combinando athlete_id e event_unit_id
        const uniqueId = `${player.athlete_id}_${player.event_unit_id}`;
        
        // Check if player is in temp selection (not marked for removal)
        const isInTempSelection = tempSelectedPlayers.some(p => 
          `${p.athlete_id}_${p.event_unit_id}` === uniqueId && !p.isRemoval);
          
        // Check if player is marked for removal
        const isMarkedForRemoval = tempSelectedPlayers.some(p => 
          `${p.athlete_id}_${p.event_unit_id}` === uniqueId && p.isRemoval);
          
        // Modifica qui: verifichiamo se il giocatore √® gi√† scelto usando l'ID univoco
        const isAlreadyChosen = chosenPlayerUniqueIds.includes(uniqueId) && !isMarkedForRemoval;
        
        // A player is affordable if their cost is within budget
        const isAffordable = playerCost <= availableBudget;
        
        
        // Create player card
        const card = document.createElement('li');
        
        // Make cards clickable if:
        // 1. They're affordable (for new selections), OR
        // 2. They're already chosen (to allow deselection)
        // 3. They're in temp selection (to allow deselection)
        card.className = `player-card ${(isAffordable || isAlreadyChosen || isInTempSelection) ? 'clickable' : 'disabled'}`;
        
        // Set background color for selected players
        if (isAlreadyChosen || isInTempSelection) {
          card.style.backgroundColor = "#0f7173"; // Cambiato da "rgba(254, 66, 8, 0.5)" a "#0f7173"
        }
        
        // Player icon container
        const iconContainer = document.createElement('div');
        iconContainer.className = 'player-icon-container';
        
        const playerIcon = document.createElement('div');
        playerIcon.className = 'player-icon';
        
        const img = document.createElement('img');
        img.src = player.picture ? `pictures/${player.picture}` : 'pictures/player_placeholder.png';
        img.onerror = function() { this.src = 'pictures/player_placeholder.png'; };
        playerIcon.appendChild(img);
        
        // Position indicator
        const posIndicator = document.createElement('div');
        posIndicator.className = `position_circle`;
        posIndicator.textContent = player.position;
        
        iconContainer.appendChild(playerIcon);
        iconContainer.appendChild(posIndicator);
        
        // Player info
        const infoContainer = document.createElement('div');
        infoContainer.className = 'player-info-container';
        
        // Player name
        const nameElement = document.createElement('div');
        nameElement.className = 'player-name';
        nameElement.textContent = player.athlete_shortname || 'Unknown';
        
        // Match info
        const matchElement = document.createElement('div');
        matchElement.className = 'player-match';
        
        // Format: COUNTRY | CONCLAVE event_unit_id
        const conclave = parseInt(player.event_unit_id);
        const conclaveLabel = (conclave === 1) ? '1' : `${conclave}ab`;

        matchElement.innerHTML = `
          <span style="font-family: 'Montserrat', sans-serif; font-weight: 800;">
            ${player.player_team_code || ''}
          </span> | CONCLAVE 
          <span style="font-family: 'Montserrat', sans-serif; font-weight: 800;">
            ${conclaveLabel}
          </span>`;

        

        infoContainer.appendChild(nameElement);
        infoContainer.appendChild(matchElement);
        
        // Player cost
        const costElement = document.createElement('div');
        costElement.className = 'player-cost';
        costElement.textContent = playerCost.toFixed(1);
        
        // Add all elements to card
        card.appendChild(iconContainer);
        card.appendChild(infoContainer);
        card.appendChild(costElement);
        
        // Add click event to toggle selection
        if (isAffordable || isAlreadyChosen || isInTempSelection) {
          card.addEventListener('click', () => {
            // If player is already chosen but not in temp selection, mark for removal
            if (isAlreadyChosen && !isInTempSelection) {
              const playerCopy = {...player, isRemoval: true};
              togglePlayerSelection(playerCopy, card);
            } else {
              togglePlayerSelection(player, card);
            }
          });
        }
        
        playerList.appendChild(card);
        renderedCount++;
      });
      
      // Se non ci sono giocatori da mostrare, mostra un messaggio
      if (renderedCount === 0) {
        const noPlayersMsg = document.createElement('li');
        noPlayersMsg.className = 'no-players-message';
        noPlayersMsg.textContent = 'Nessun giocatore disponibile';
        playerList.appendChild(noPlayersMsg);
      }
    }
  </script>
</body>
</html>


